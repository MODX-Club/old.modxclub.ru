import React, { Component } from 'react';

import ChatMessage from './message/';

import TextEditor from '../editor/';



export default class MainChat extends Component {

  // state = {
  //   data: [],
  // }

  constructor(props){

    super(props);

    this.state = {
    };

    var data = [];

    // if(props.proxy.chat_messages && props.proxy.chat_messages.length){
    if(props.document.chat_messages && props.document.chat_messages.length){

      var messages = [];

      // props.proxy.chat_messages.map(function(message){
      props.document.chat_messages.map(function(message){
        messages.push(message);
      });

      data = this.prepare_chat_data(messages);
      // this.state.data = this.prepare_chat_data(props.proxy.chat_messages);
    }

    this.state.data = data;
  }


  prepare_chat_data(chat_messages){
    var data = [];

    for(var i in chat_messages){
      var message = chat_messages[i];
      message.key = i + '_' +(message.ts || message.id);

      data.push(message);
    }

    data.reverse();

    return data;
  }

  setScroll(){

    if(typeof window !== "undefined"){
      let wrapper = window.document.getElementById('chat-wrapper');
      if(typeof wrapper !== "undefined" && wrapper){
        wrapper.scrollTop = wrapper.scrollHeight - wrapper.offsetHeight;
      }

    }
  }

  addMessage(message){
    // console.log(this.state.data)
    // console.log(message)
    var data = this.state.data;
    data[data.length] = message;
    this.setState({
      data: data,
    });
  }

  componentWillReceiveProps(nextProps){

    // let props = nextProps;
    // if(props.proxy.chat_messages && props.proxy.chat_messages.length){
    //   this.setState({
    //     data: props.proxy.chat_messages,
    //   });
    //   this.setScroll();
    // }

    for(var i in nextProps.proxy.inbox){
      let message = nextProps.proxy.inbox[i];

      // console.log("Main Chat message", message);

      var data = this.state.data;

      if(
        !message.readed
        // && message.original_message
        // && message.original_message.type == 'chat_message'
        && message.type == 'chat_message'
      // && message.original_message.ts == this.currentTs
      ) {

        // console.log(message);
        // alert("sdfdsf");

        this.props.proxyActions.MessageReaded(message);

        /*
        * Если действие было создано текущим пользователем,
        * то пропускаем его
        * */
        if(message.object.action_ts == this.state.action_ts){
          continue;
        }
        // if(message.original_message.ts == this.currentTs){
        //   this.props.proxyActions.MessageReaded(message);
        // }

        /*
        * Если это редактированное сообщение, то ищем его в списке текущих сообщений.
        * Если его там нет, то пропускаем.
        * Если новое сообщение, то просто добавляем
        * */
        // console.log("Message", message);
        if(message.object.editedon){
          data.map(function(item){
            if(item.id == message.object.id){
              // console.log("Item", item);
              // console.log("Message", message);
              Object.assign(item, message.object);
              // console.log("Item", item);
              // console.log("Data", data);
            }
          });
        }
        else{
          data.push(Object.assign({},message.object,{
            key: i + '_' +(message.object.ts || message.object.id),
            // user_id: this.props.user.id,
            // username: this.props.user.username,
            // photo: this.props.user.photo,
          }));
        }


      }

      this.setState({
        data: data,
      });
    }
    return true;
  }

  onBeforeSendMessage(message){
    // console.log('onBeforeSendMessage', message);

    // Фиксируем, чтобы знать когда сообщение отправляем
    this.state.action_ts = message.ts;
  }

  componentDidMount(){

    this.setScroll();
  }

  componentDidUpdate(prevProps, prevState){


    this.setScroll();
    return true;
  }

  render(){

    // console.log('this.state.data', this.state.data);

    // return null;
    return (
      <div>
        <div id="chat-wrapper">
          <div>

            {this.state.data.map((item) => {
              return <ChatMessage
                key={item.key || item.ts || item.id} item={item}
                user={this.props.user}
                onBeforeSendMessage={this.onBeforeSendMessage.bind(this)}
                documentActions={this.props.documentActions}
              />
            }, this)}

          </div>
        </div>
        <div>
          <TextEditor
            inEditMode={true}
            allow_edit={true}
            documentActions={this.props.documentActions}
            onBeforeSendMessage={this.onBeforeSendMessage.bind(this)}
            onMessageEdded={this.addMessage.bind(this)}
            target_id={this.props.document.id}
            clearOnSave={true}
          />

        </div>
      </div>
    );
  }
}
