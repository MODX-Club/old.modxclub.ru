import React, { Component } from 'react';
import moment from 'moment';

import { createStyleSheet } from 'jss-theme-reactor';
import customPropTypes from 'material-ui/utils/customPropTypes';

import Typography from 'material-ui/Typography';
import Badge from 'material-ui/Badge';
import IconButton from 'material-ui/IconButton';
import IconEdit from 'material-ui-icons/Create';
import IconDelete from 'material-ui-icons/Delete';
import ExpandIcon from 'material-ui-icons/ExpandMore';
import ExpandLessIcon from 'material-ui-icons/ExpandLess';
import CommentsEmpty from 'material-ui-icons/ModeComment';
import CommentsNotEmpty from 'material-ui-icons/InsertComment';

import ArticleInfoComments from './articleinfocomments';

import Avatar from '../Avatar';

import Card, {
  CardHeader,
  CardContent,
  CardMedia,
  CardActions,
} from 'material-ui/Card';

import TextField from 'material-ui/TextField';

import TextEditor from '../editor/';
import TopicEditor from '../editor/topiceditor';

// import style from './styles';

import md5 from 'md5';

import { CONNECTOR_URL } from '../const/';

import { Link } from 'react-router-dom';

const defaultProps = {
  fullView: true,
  editor: false,
  allow_edit: false,
  isNew: false,
  inEditMode: false,
  document: {},
}

var classes;

const styleSheet = createStyleSheet('Article', (theme) => ({
  root: {

    marginTop: 15,
    marginBottom: 30,

    '& pre': {
      whiteSpace: 'pre-line',
    },
  },
  bullet: {
  },
  header: {
    '& a': {
      textDecoration: 'none',
    },
  },
}));

export default class Article extends Component {

  constructor(props) {
    super(props);

    this.state = {
      editor: props.editor,
      isNew: props.isNew,
      inEditMode: props.inEditMode,
      // user: props.user,
      fullView: props.fullView,
      document: props.document,
      allow_edit: props.allow_edit,
      pagetitle: props.document ? props.document.pagetitle : "",
      content: props.document ? props.document.content : "",
      comments: props.document && props.document.comments ? props.document.comments : [],
      errors: {},
      show_message: "",
    };
  }

  addMessage(message){
    var comments = this.state.comments;
    comments.push(message);
    this.setState({
      comments: comments,
    });
  }


  onChangePagetitle(e, value){
    // console.log('onChangePagetitle', e, e.target, value);

    this.setState({
      pagetitle: e.target.value,
    });
  }

  onRequestComplite(state){

    var newState = {
      errors: state.errors,
    }

    if(state.success == true && state.object){
      Object.assign(newState, {
        document: state.object,
        inEditMode: false,
        isNew: false,
        show_message: state.message || "Топик успешно сохранен",
      });
    }

    this.setState(newState);
  }

  clearError(){
    this.setState({
      errors: {},
    });
  }

  loadFullData(){

    if(!this.state.document.thread_id){
      return;
    }

    var body = new FormData();

    var data = {
      // format: "json",
      thread_id: this.state.document.thread_id,
      limit: 0,
    };

    for(var i in data){
      body.append(i, data[i]);
    };


    var newState = {
      fullViewLoaded: true,
    };

    fetch(CONNECTOR_URL +'?pub_action=topics/comments/getdata',{
      credentials: 'same-origin',
      method: "POST",
      body: body,
    })
      .then(function (response) {

        return response.json()
      })
      .then(function (data) {


        if(data.success == true && data.object){

          var tags = [];

          Object.assign(newState, {
            comments: data.object || [],
          });

          this.setState(newState);
        }
        else{
          console.error(data.message || "Ошибка выполнения запроса");
        }


        this.setState(newState);

      }.bind(this))
      .catch((error) => {
          console.error('Request failed', error);
          this.setState(newState);
        }
      );
  }

  componentWillReceiveProps(nextProps){

    /*
     * Если изменились комментарии в документе
     * */
    if(
      nextProps.document
      && this.props.document
      && nextProps.document.comments
      && this.props.document.comments
      && md5(nextProps.document.comments) != md5(this.props.document.comments)
    ){
      this.setState({
        comments: nextProps.document.comments,
      });
    }

    return true;
  }

  componentWillUpdate(nextProps, nextState){

    // Подгружаем полные данные
    if(
      nextState.fullView != this.state.fullView
      && nextState.fullView === true
      && this.state.fullViewLoaded !== true
    ){
      this.loadFullData();
    }

    return true;
  }

  componentWillMount(){

    classes = this.context.styleManager.render(styleSheet);
  }

  setFullView = () => {

    this.setState({
      fullView: true,
    })
  }

  render(){

    var document = this.state.document;

    if(!document && this.state.isNew !== true){
      return null;
    }

    var buttons = [];

    var allow_edit = this.state.allow_edit;

    if(this.state.fullView === true){
      buttons.push(<IconButton
        key="expandLess"
        onTouchTap={() => {
          this.setState({
            fullView: false,
          })
        }}

      >
        <ExpandLessIcon
        />
      </IconButton>);
    }
    else{
      buttons.push(<IconButton
        key="expandMore"
        onTouchTap={this.setFullView}

      >
        <ExpandIcon
        />
      </IconButton>);
    }

    if(document.comments_count > 0){
      buttons.push(<Badge
        key="comments_not_empty"
        badgeContent={document.comments_count}
        onTouchTap={() => {
          this.setState({
            fullView: true,
          })
        }}
        style={{
          cursor: "pointer",
        }}
      >
        <CommentsNotEmpty
        />
      </Badge>);
    }
    else{
      buttons.push(<CommentsEmpty
        key="comments_empty"
      />);
    }

    if(
      document.id
      && this.props.user
      && this.props.user.id > 0
      && (this.props.user.id == document.createdby || this.props.user.id == 2)
    ){

      // if(this.state.fullView === true){

        allow_edit = true;

        if(this.state.inEditMode !== true){
          buttons.push(<IconButton
            key="edit"
            onTouchTap={() => {
              this.setState({
                inEditMode: true,
              })
            }}

          >
            <IconEdit
            />
          </IconButton>);

          if(this.props.user.id == 2){

            buttons.push(<IconButton
              key="delete"

            >
              <IconDelete
              />
            </IconButton>);
          }
        }
      // }
    }


    var date = document.publishedon || document.createdon;

    return <Card
      className={classes.root}
    >

      {this.state.inEditMode !== true ?
        <CardHeader
          className={classes.header}
          avatar={<Link
            to={`/profile/${document.author_username}/`}
            href={`/profile/${document.author_username}/`}
          >
            <Avatar username={document.author_username} avatar={document.author_avatar}/>
          </Link>}
          title={<Link
            to={document.uri}
            href={document.uri}
            className="Card--title"
          >
            {this.state.pagetitle}
          </Link>}
          subheader={<div>{(date ? moment(new Date((date) * 1000)).format('YYYY.MM.DD HH:mm') + " " : null)}
            <Link
              to={document.blog_uri}
              href={document.blog_uri}
              // onClick={(e, event) => {
              //   e.nativeEvent.preventDefault();
              //   e.nativeEvent.stopPropagation();
              //   return false;
              // }}
              // onTouchTap={(e) => {
              //   this.props.documentActions.LoadDocument(document.blog_uri);
              // }}
            >
              {document.blog_pagetitle}
            </Link>

          </div>}
        >


        </CardHeader>
        :
        <CardContent>
          <TextField
            name="pagetitle"
            value = {this.state.pagetitle}
            label="Название топика"
            error={this.state.errors.pagetitle && this.state.errors.pagetitle != ""}
            onFocus={() => {this.clearError()}}
            onChange={(e, value) => {this.onChangePagetitle(e, value)}}
          />
        </CardContent>
      }

      <CardContent>

        <TopicEditor
          className="topic-editor"
          id={document.id}
          content={document.content}
          pagetitle={this.state.pagetitle}
          document={document}
          inEditMode={this.state.inEditMode || false}
          fullView={this.state.fullView === true || this.state.inEditMode}
          allow_edit={allow_edit}
          onRequestComplite={(state) => this.onRequestComplite(state)}
          setFullView={this.setFullView}
        />


      </CardContent>


        {buttons.length > 0 ?
          <CardActions>
            {buttons}
          </CardActions>
          : null}

        {this.state.fullView === true && (document.id > 0 && this.state.inEditMode !== true) ? <ArticleInfoComments
            document={document}
            comments={this.state.comments}
            user={this.props.user}
          /> : null}

        {this.state.fullView === true && (document.id > 0 && this.state.inEditMode !== true) ? <TextEditor
            inEditMode={true}
            allow_edit={true}
            target_id={document.id}
            documentActions={this.props.documentActions}
            onMessageEdded={this.addMessage.bind(this)}
            clearOnSave={true}
          /> : null}
    </Card>;
  }
}

Article.defaultProps = defaultProps;

Article.contextTypes = {
  styleManager: customPropTypes.muiRequired,
};

